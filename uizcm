#
# Started from zle or from command line
#

emulate -LR zsh
setopt extendedglob typesetsilent

autoload __zcmdr-process-buffer __zcmdr-usetty-wrapper __zcmdr-list __zcmdr-list-input __zcmdr-list-draw

[[ "${ZCMDR[stdlib_sourced]}" != "1" ]] && source "${ZCMDR_REPO_DIR}/lib/stdlib.lcmdr"

##
## Main code
##

# Measure and limit generation time
typeset -F SECONDS=0.0
local -F start_seconds=$SECONDS

local limit_seconds
zstyle -s ":plugin:zcommodore" time_limit limit_seconds || limit_seconds="500"
[[ "$limit_seconds" != <-> ]] && limit_seconds="500"

#
# Business logic follows
#

local curcontext=":zle:$WIDGET"
local MATCH MBEGIN MEND
typeset -a OUTPUT

#
# Last N git commits
#

local git_log_count
zstyle -s ":plugin:zcommodore" git_log_count || git_log_count="5"
[[ "$git_log_count" != <-> ]] && git_log_count="5"

local -a gitcmd gitout
gitcmd=( git -C "${ZCMDR[current_project]}" log --max-count="$git_log_count" --pretty=format:'%h%x01%s%x01%d%x01%cr%x01%an' --abbrev-commit )
gitout=( "${(@f)"$( "${gitcmd[@]}" )"}" )

local -a gitout2 arrentry
local IFSBKP="$IFS"
local IFS=$'\1'
for entry in "${gitout[@]}"; do
    # hash \1 message \1 repo info \1 date \1 author
    arrentry=( ${=entry} )
    gitout2+=( "${CMDR_GREEN}${arrentry[1]}${CMDR_GREEN_E} ${CMDR_CYAN}${(q-)arrentry[2]}${CMDR_CYAN_E} ${CMDR_MAGENTA}((${arrentry[4]}))${CMDR_MAGENTA_E} \`${arrentry[5]}\`" )
done
IFS="$IFSBKP"

OUTPUT+=( "${CMDR_RED}'Current HEAD commits of ${CMDR_RED_E}${CMDR_GREEN}${(q)ZCMDR[current_project]:t}${CMDR_GREEN_E}${CMDR_RED}'${CMDR_RED_E}" "${gitout2[@]}" )

local ZCMDRLIST_GENERATION_TIME="$(( SECONDS - start_seconds ))"
ZCMDRLIST_GENERATION_TIME="${ZCMDRLIST_GENERATION_TIME[1,5]}"

#
# Invoke the list, handle outcome
#

local ZCMDRLIST_WRAPPER_BIT=""
__zcmdr-usetty-wrapper __zcmdr-list-wrapper "${OUTPUT[@]}" "$ZCMDRLIST_GENERATION_TIME"

zle && zle redisplay

if [ -z "$ZCMDRLIST_WRAPPER_BIT" ]; then
    return 1
fi

return 0

# vim:ft=zsh
