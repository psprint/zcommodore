emulate -LR zsh
setopt extendedglob typesetsilent

[[ -z "${fg_bold[green]}" ]] && builtin autoload -Uz colors && colors

-zcmdr_usage_zcm_feature() {
    print -- "Feature management tool. You can EDIT files belonging to feature (with"
    print -- "editor from e.g. \$EDITOR variable), CREATE feature from set of files"
    print -- "or from *commit*, UPDATE files of a feature and DELETE whole feature."
    print
    print -- "${fg_bold[green]}Usage: zcm-feature [-x|--extract] [--[no]cd] {feature-name}${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-l|--list} [project name, can be pattern]${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-ll|-l -l} [project name, can be pattern]${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-L} [feature name, can be pattern]${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-LL|-L -L} [feature name, can be pattern]${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-c|--create} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-C|--create-from-commits} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-a|--add} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-y|--delete} {feature-name} {file1} {file2} ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-Y|--delete-feature} {feature-name}${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-S|--set-commits} {feature-name} {commit SHA} [commit SHA] ...${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-d|--diff} {feature-name}${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-f|--files} {feature-name}${reset_color}"
    print -- "${fg_bold[green]}       zcm-feature {-b|--backup} {feature-name}${reset_color}"
    print
    print -- "-h|--help                This message"
    print -- "-x|--extract             Take files also from commits (for editing)"
    print -- "--cd                     CD to project's dir before editing (overrides \"cd_at_edit\" Zstyle)"
    print -- "--nocd                   Don't CD, use absolute paths (overrides \"cd_at_edit\" Zstyle)"
    print -- "-l/--list                List features of current or given project"
    print -- "-ll/-l -l                Long list – shows attached files and commits"
    print -- "-L                       Match and list features of all projects"
    print -- "-LL/-L -L                Long list – shows attached files and commits"
    print -- "-c/--create              Create new feature from supplied files"
    print -- "-C/--create-from-commits Create new feature from files of given commits, attach the commits"
    print -- "-a/--add                 Add given files to given feature"
    print -- "-y/--delete              Delete given files from given feature"
    print -- "-Y/--delete-feature      Forget given feature (delete)"
    print -- "-S/--set-commits         Attach given commits to given feature, replacing previous ones"
    print -- "-d/--diff                Show contents of commits of given features (diffs)"
    print -- "-f/--files               Show files attached via commits"
    print -- "-b/--backup              Create archive with files of a feature (-x: also commit files)"
    print -- "-p/--prompt              Prompt for feature name (to be used with -c, -C, -a, etc.)"
    print -- "-P/--project             Which project to set for new feature (for scripting, with -c or -C)"
    print
    print -- "-q/--quiet      Operate without outputting messages"
    print -- "-v/--verbose    Print more status messages"
    return 0
}

local -A opthash
local -a optarr
zparseopts -D -E -A opthash x -extract -cd -nocd l+=optarr -list L+=optarr c -create C -create-from-commits \
            a -add y -delete Y -delete-feature S -set-commits d -diff f -files b -backup p -prompt P -project \
            q -quiet v -verbose h -help || { -zcmdr_usage_zcm; return 1; }

integer list=0 LIST=0 create=0 create_from_commits=0 add=0 delete=0 delete_feature=0 set_commits=0 diff=0 filesopt=0 backup=0 quiet=0 verbose=0
integer extract=0 cdopt=0 nocdopt=0 promptopt=0 project=0

# Help
(( ${+opthash[-h]} + ${+opthash[--help]} )) && { -zcmdr_usage_zcm_feature; return 0; }

(( extract = ${+opthash[-x]} + ${+opthash[--extract]} ))
(( cdopt = ${+opthash[--cd]} ))
(( nocdopt = ${+opthash[--nocd]} ))
(( list = ${+opthash[-l]} + ${+opthash[--list]} ))
(( LIST = ${+opthash[-L]} ))
(( create = ${+opthash[-c]} + ${+opthash[--create]} ))
(( create_from_commits = ${+opthash[-C]} + ${+opthash[--create-from-commits]} ))
(( add = ${+opthash[-a]} + ${+opthash[--add]} ))
(( delete = ${+opthash[-y]} + ${+opthash[--delete]} ))
(( delete_feature = ${+opthash[-Y]} + ${+opthash[--delete-feature]} ))
(( set_commits = ${+opthash[-S]} + ${+opthash[--set-commits]} ))
(( diff = ${+opthash[-d]} + ${+opthash[--diff]} ))
(( filesopt = ${+opthash[-f]} + ${+opthash[--files]} ))
(( backup = ${+opthash[-b]} + ${+opthash[--backup]} ))
(( promptopt = ${+opthash[-p]} + ${+opthash[--prompt]} ))
(( project = ${+opthash[-P]} + ${+opthash[--project]} ))
(( quiet = ${+opthash[-q]} + ${+opthash[--quiet]} ))
(( verbose = ${+opthash[-v]} + ${+opthash[--verbose]} ))

if (( LIST + list + create + create_from_commits + add + delete + delete_feature + set_commits + diff + filesopt + backup > 1 )); then
    print "Conflicting options given, please use single operation specifier (like -c, -C, -a, -b, etc.)"
    return 2
fi

# Multiple -l option
if [[ "${optarr[(I)-l]}" != "0" && "${optarr[(I)-l]}" != "${optarr[(i)-l]}" ]]; then
    (( list += 1 ))
fi

# Multiple -L option
if [[ "${optarr[(I)-L]}" != "0" && "${optarr[(I)-L]}" != "${optarr[(i)-L]}" ]]; then
    (( LIST += 1 ))
fi

[[ "${ZCMDR[stdlib_sourced]}" != "1" ]] && source "${ZCMDR_REPO_DIR}/lib/stdlib.lcmdr"

local features_path="$ZCMDR_CONFIG_DIR/var/features"
[[ ! -d "$features_path" ]] && command mkdir -p "$features_path"
integer retcode

local selected_editor cd_at_edit editor_use_tabs
zstyle -s ":plugin:zcommodore" editor selected_editor || selected_editor="${EDITOR:-vim}"
zstyle -T ":plugin:zcommodore" cd_at_edit && cd_at_edit="yes" || cd_at_edit="no"
zstyle -T ":plugin:zcommodore" editor_use_tabs && editor_use_tabs="yes" || editor_use_tabs="no"

(( cdopt )) && cd_at_edit="yes"
(( nocdopt )) && cd_at_edit="no"

local nprojects
zstyle -s ":plugin:zcommodore" nprojects nprojects || nprojects="7"
[[ "$nprojects" != <-> ]] && nprojects="7"
[[ "$nprojects" = "0" ]] && nprojects="1"

#
# Functions
#

-zcmdr_verify_feature() {
    local feature="$1"

    if [[ "$feature" != [[:alnum:]_-]## ]]; then
        print "Improper feature name: \`$feature'. Allowed are letters, _, - and digits."
        return 3
    fi

    local feature_file="${features_path}/${feature}.conf"

    if [[ ! -d "${ZCMDR[current_project]}" ]]; then
        print "Current project points to incorrect path, aborting: \`${ZCMDR[current_project]}'"
        print "(consider running zcm in a project directory or zcm -l)"
        return 4
    fi

    if [[ "$2" != "can_exist" && "$2" != "must_exist" && -f "$feature_file" ]]; then
        local -a entries
        entries=( "${(@f)"$(<$feature_file)"}" )

        local project_path="${entries[2]/(#s)$HOME/~}"
        print "Feature \`$feature' already exists, belongs to project ${fg_bold[green]}${project_path}${reset_color}"
        return 5
    fi

    if [[ "$2" = "must_exist" && ! -f "$feature_file" ]]; then
        print "Feature \`$feature' doesn't exist (at any project)"
        return 6
    fi

    return 0
}

# Search through recently used projects
# to find the path to repository of the
# project given as input
#
# $1 - $ZCMDR[current_project]
-zcmdr_find_repo_path_in_recents() {
    local project="$1" p found="no"
    local -a all_circular_paths last_entries

    -zcmdr_stdlib_circular_paths "last_project"
    all_circular_paths=( "${reply[@]}" )

    REPLY=""
    for p in "${all_circular_paths[@]}"; do
        last_entries=( "${(@f)"$(<$p)"}" )
        if [[ "${last_entries[1]}" = "$project" ]]; then
            REPLY="${last_entries[2]}"
            found="yes"
            break
        fi
    done

    # Testable
    [[ "$found" = "yes" ]] && return 0 || return 1
}

#
# Project?
#
local project_override="" root_dir_override=""
if (( project )); then
    if (( create + create_from_commits != 1 )); then
        print "-P is to be used with one of -c, -C"
        return 33
    fi
    project_override="$1"
    shift

    if [[ ! -d "$project_override" ]]; then
        print "Provided (via -P) project path doesn't exist"
        return 34
    fi

    if ! -zcmdr_find_repo_path_in_recents "$project_override"; then
        print "Could not find repository of project \`${project_override:t:r}\' because"
        print "the project is not remembered in recent-projects database."
        print "Cannot override project with -P option, aborting.."
        return 35
    else
        root_dir_override="$REPLY"
    fi

    print -- "Overriding project with ${fg[cyan]}${project_override/(#s)$HOME/~}${reset_color}"
fi

#
# Prompt?
#
if (( promptopt )); then
    print "Enter feature name or l {pattern}, L {pattern} to list existing features"
    local ftname
    while (( 1 )); do
        ftname=""
        vared -cp "Feature name: " ftname

        [[ -z "$ftname" ]] && continue

        if [[ "$ftname" = L[[:space:]]* || "$ftname" = "L" ]]; then
            zcm-feature -L "${ftname##L #}"
        elif [[ "$ftname" = l[[:space:]]* || "$ftname" = "l" ]]; then
            zcm-feature -l "${ftname##l #}"
        elif [[ "$ftname" = LL[[:space:]]* || "$ftname" = "LL" ]]; then
            zcm-feature -LL "${ftname##LL #}"
        elif [[ "$ftname" = ll[[:space:]]* || "$ftname" = "ll" ]]; then
            zcm-feature -ll "${ftname##ll #}"
        elif [[ "$ftname" = "q" ]]; then
            return 0
        elif [[ "$ftname" != [[:alnum:]_-]## ]]; then
            print "Improper feature name: \`${fg_bold[magenta]}$ftname${reset_color}'. Allowed are letters, _, - and digits."
        else
            echo "Will use feature name: \`${fg_bold[magenta]}$ftname${reset_color}'."
            break
        fi
    done

    set "$ftname" "$@"
fi

#
#
# List
#

if (( list )); then
    if [[ "$#" -gt "1" ]]; then
        print "At most 1 argument is needed – a ${fg_bold[cyan]}project name${reset_color} (can be a pattern, which should be quoted)"
        return 31
    fi

    local project_query="$1"
    if [[ -n "$project_query" ]]; then
        if [[ "$project_query" = "*" ]]; then
            print "Current project: ${fg_bold[green]}${ZCMDR[current_project]:t:r}${reset_color}, features of projects \`${fg_bold[cyan]}*${reset_color}' follow:"
        else
            local query="*$project_query*"
            query="${query//\*\*/*}"
            query="${query//\*\*/*}"
            print "Current project: ${fg_bold[green]}${ZCMDR[current_project]:t:r}${reset_color}, features of projects \`${fg_bold[cyan]}*${project_query}*${reset_color}' follow:"
        fi
    else
        print "Current project: ${fg_bold[green]}${ZCMDR[current_project]:t:r}${reset_color}, features follow:"
    fi
    print


    local -a features
    features=( "${features_path}"/*.conf(Nom) )
    if [[ -z "${features[1]}" ]]; then
        print "No features currently defined (for any project)"
        return 0
    fi

    local -a found entries
    local pth
    for pth in "${features[@]}"; do
        entries=( "${(@f)"$(<$pth)"}" )
        if [[ -n "$project_query" && "${entries[2]}" = *$~project_query* ]]; then
            found+=( "$pth" )
        elif [[ -z "$project_query" && "${entries[2]}" = "${ZCMDR[current_project]}" ]]; then
            found+=( "$pth" )
        fi
    done

    if [[ -z "${found[1]}" ]]; then
        if [[ -n "$project_query" ]]; then
            if [[ "$project_query" = "*" ]]; then
                print "No project names matched \`${fg_bold[cyan]}*${reset_color}'"
            else
                local query="*$project_query*"
                query="${query//\*\*/*}"
                query="${query//\*\*/*}"
                print "No project names matched \`${fg_bold[cyan]}$query${reset_color}'"
            fi
        else
            print "Project ${fg_bold[green]}${ZCMDR[current_project]}${reset_color} doesn't have features defined"
        fi
        return 0
    fi
elif (( LIST )); then
    if [[ "$#" -gt "1" ]]; then
        print "At most 1 argument is needed – a ${fg_bold[magenta]}feature name${reset_color} (can be a pattern, which should be quoted)"
        return 32
    fi

    local feature_query="$1"
    if [[ -n "$feature_query" ]]; then
        if [[ "$feature_query" = "*" ]]; then
            print "Features matching \`${fg_bold[magenta]}*${reset_color}' follow:"
        else
            print "Features matching \`${fg_bold[magenta]}*${feature_query}*${reset_color}' follow:"
        fi
    else
        print "All features for all projects follow:"
    fi
    print


    local -a found
    if [[ -z "$feature_query" ]]; then
        found=( "${features_path}"/*.conf(Nom) )
    else
        found=( "${features_path}"/*$~feature_query*.conf(Nom) )
    fi

    if [[ -z "${found[1]}" ]]; then
        if [[ -z "$feature_query" ]]; then
            print "No features currently defined (for any project)"
        else
            print "No matching features"
        fi
        return 0
    fi
fi

if (( list + LIST )); then
    local -a files commits
    for pth in "${found[@]}"; do
        entries=( "${(@f)"$(<$pth)"}" )

        local feature="${pth:t:r}"
        if (( list < 2 && LIST < 2 )); then
            print -n -- "${fg_bold[magenta]}$feature${reset_color}"
        else
            print -n -- "${fg_bold[magenta]}=== $feature ===${reset_color}"
        fi

        local project_name="${entries[2]}"
        project_name="${project_name:t:r}"

        if [[ -n "$project_query" || -n "$feature_query" ]]; then
            print -- " (${fg_bold[cyan]}$project_name${reset_color})"
        else
            print
        fi

        if (( list > 1 || LIST > 1 )); then
            files=( "${(z@)entries[3]}" )
            if [[ "${files[1]}" != "files" ]]; then
                print -- "Improper 3rd line in the feature file, should begin with \`files' string"
            elif [[ "${#files}" -gt 1 ]]; then
                shift files
                print -- "${fg_bold[green]}Files${reset_color}:"
                print -rl -- "${(Q)files[@]}"
            fi

            commits=( "${(z@)entries[4]}" )
            if [[ "${commits[1]}" != "commits" ]]; then
                print -- "Improper 4th line in the feature file, should begin with \`commits' string"
            elif [[ "${#commits}" -gt 1 ]]; then
                shift commits
                print -- "${fg_bold[green]}Commits${reset_color}:"
                print -rl -- "${(Q)commits[@]}"
            fi

            print
        fi
    done
    return 0
fi

#
# Create
#

if (( create )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to create and a file to attach to the feature"
        return 7
    fi

    local feature="$1"
    shift

    local -a files
    files=( "$@" )

    local feature_file="${features_path}/${feature}.conf"

    -zcmdr_verify_feature "$feature"
    retcode=$?
    (( retcode )) && return $retcode

    local project_line="${ZCMDR[current_project]}"
    [[ -n "$project_override" ]] && project_line="$project_override"
    files=( "${(qq)files[@]}" )
    local files_line="files ${files[*]}"
    local commits_line="commits"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    print -- "Feature ${fg_bold[green]}$feature${reset_color} created (project: ${fg_bold[green]}${project_line:t:r}${reset_color}), has the files / directories:"
    print -rl -- "${(Q)files[@]}"
    return 0
fi

#
# Create from commits
#
# This is specific as it copies files from commits
# as feature's original files. This doesn't happen
# when setting commits of a feature (-S).
#

if (( create_from_commits )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, name of feature to create and a commit SHA"
        return 8
    fi

    local feature="$1"
    shift

    local -a commits
    commits=( "$@" )

    local feature_file="${features_path}/${feature}.conf"

    -zcmdr_verify_feature "$feature"
    retcode=$?
    (( retcode )) && return $retcode

    local root_dir="${ZCMDR[current_repo]}"
    [[ -n "$root_dir_override" ]] && root_dir="$root_dir_override"

    [[ ! -d "$root_dir" ]] && { print "Repository dir doesn't exist or isn't directory (\`$root_dir')"; return 9; }

    local cmt
    local -a files
    local -aU save_files
    integer error=0
    if [[ -d "$root_dir"/.git ]]; then
        for cmt in "${commits[@]}"; do
            files=( ${(f)"$( git -C "$root_dir" rev-parse --verify "${cmt}^{commit}" 2>/dev/null )"} )
            if [[ "${#files}" = "0" ]]; then
                print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                error+=1
                continue
            fi
            # Get list of files (3 steps) of the commit
            files=( ${(f)"$( git -C "$root_dir" show --name-status --no-renames "$cmt" )"} )
            files=( "${(@M)files:#((#s)[ADM][ADM]#[[:space:]]##*|(#s)[ ][ADM][[:space:]]##*)}" )
            files=( "${files[@]/(#b)(#s)[[:alpha:]]##[[:space:]]##(*)(#e)/${match[1]}}" )

            save_files+=( "${files[@]}" )
        done
    elif [[ -d "$root_dir"/.hg ]]; then
        for cmt in "${commits[@]}"; do
            files=( ${(f)"$( hg --cwd "$root_dir" log -r "${cmt}" -T {node}\\n 2>/dev/null )"} )
            if [[ "${#files}" = "0" ]]; then
                print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                error+=1
                continue
            fi
            # Get list of files of the commit
            files=( ${(f)"$( hg --cwd "$root_dir" log -r "$cmt" -T {files}\\n )"} )

            save_files+=( "${files[@]}" )
        done
    else
        print "Cannot create feature from given commits – project isn't Git nor Hg repository"
        return 10
    fi

    if (( error > 0 )); then
        print "${fg_bold[red]}$error commit(s) not found, refusing to create feature"
        return 16
    fi

    local project_line="${ZCMDR[current_project]}"
    [[ -n "$project_override" ]] && project_line="$project_override"
    files=( "${(qq)save_files[@]}" )
    local files_line="files ${files[*]}"
    commits=( "${(q)commits[@]}" )
    local commits_line="commits ${commits[*]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    print "Feature ${fg_bold[green]}\`$feature'${reset_color} created (project: ${fg_bold[green]}${project_line:t:r}${reset_color}) with files from the commit(s)"
    return 0
fi

if (( add )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to update and a file to attach to the feature"
        return 11
    fi

    local feature="$1"
    shift

    local -aU files
    files=( "$@" )

    -zcmdr_verify_feature "$feature" "can_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "The feature \`$feature' belongs to project: ${fg_bold[green]}\`${entries[2]:t:r}'${reset_color}. Proceed with update? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "n" ]]; then
            echo "Aborting.."
            return 12
        else
            project_line="${entries[2]}"
        fi
    fi

    # Split current files to keep them uniq
    local -a current
    current=( "${(z@)entries[3]}" )
    # z-flag can do tricks IIRC
    if [[ -z "${current[1]}" ]]; then
        current=( )
    else
        shift current
    fi

    files=( "${files[@]/(#s)$project_line\//}" )
    integer before_count="${#current}"
    files=( "${(qq)files[@]}" "${current[@]}" )
    integer after_count="${#files}"

    local files_line="files ${files[*]}"
    local commits_line="${entries[4]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    if (( quiet == 0 )); then
        if (( verbose == 1 )); then
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no new files):"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated, has the files / directories:"
            fi
            print -rl -- "${(Q)files[@]}"
        else
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no new files)"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated"
            fi
        fi
    fi
    return 0
fi

if (( delete )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to update and a file to remove from the feature"
        return 13
    fi

    local feature="$1"
    shift

    # Files to remove
    local -aU files
    files=( "$@" )

    -zcmdr_verify_feature "$feature" "can_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "The feature \`$feature' belongs to project: ${fg_bold[green]}\`${entries[2]:t:r}'${reset_color}. Proceed with deletion of files? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "n" ]]; then
            echo "Aborting.."
            return 14
        else
            project_line="${entries[2]}"
        fi
    fi

    # Split current files to keep them uniq
    local -a current
    current=( "${(z@)entries[3]}" )
    # z-flag can do tricks IIRC
    if [[ -z "${current[1]}" ]]; then
        current=( )
    else
        shift current
    fi

    files=( "${files[@]}" )

    local f f2
    integer before_count="${#current}" found_idx
    for f in "${files[@]}"; do
        f2="${f/(#s)$project_line\//}"
        f2="${(qq)f2}"
        f="${(qq)f}"

        # Absolute path
        found_idx="${current[(I)$f]}"
        if [[ "$found_idx" != "0" ]]; then
            (( quiet )) || echo "Removing ${(Q)f}..."
            current[found_idx]=()
        fi

        # Relative path
        found_idx="${current[(I)$f2]}"
        if [[ "$found_idx" != "0" ]]; then
            (( quiet )) || echo "Removing ${(Q)f2}..."
            current[found_idx]=()
        fi
    done

    integer after_count="${#current}"

    local files_line="files ${current[*]}"
    local commits_line="${entries[4]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    if (( quiet == 0 )); then
        [[ "$before_count" != "$after_count" || "$answer" = "y" ]] && print

        if (( verbose == 1 )); then
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no files deleted):"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated, has the files / directories:"
            fi
            print -rl -- "${(Q)current[@]}"
        else
            if [[ "$before_count" = "$after_count" ]]; then
                print -- "Feature ${fg_bold[green]}$feature${reset_color} remained the same (no files deleted)"
            else
                print -- "Feature ${fg_bold[green]}$feature${reset_color} updated (files deleted)"
            fi
        fi
    fi
    return 0
fi

if (( delete_feature )); then
    if [[ "$#" -ne "1" ]]; then
        print "Exactly one argument is needed: name of feature to delete"
        return 15
    fi

    local feature="$1"

    -zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    if (( quiet == 0 )); then
        local -a entries
        entries=( "${(@f)"$(<$feature_file)"}" )
        local project_path="${entries[2]/(#s)$HOME/~}"

        print "Are you sure want to delete ${fg_bold[green]}\`$feature'${reset_color} belonging to project ${fg_bold[green]}\`$project_path'${reset_color}? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "y" ]]; then
            (( verbose )) && print "Removing feature \`$feature'..."
            command rm -f "$feature_file"
            print "Done."
        else
            print "Aborting."
            return 16
        fi
    else
        (( verbose )) && print "Removing feature \`$feature'..."
        command rm -f "$feature_file"
        (( verbose )) && print "Done."
    fi

    return 0
fi

if (( set_commits )); then
    if [[ "$#" -lt "2" ]]; then
        print "At least 2 arguments are needed, feature to update and a commit to set the feature to"
        return 17
    fi

    local feature="$1"
    shift

    local -aU commits
    commits=( "$@" )

    -zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"
    local root_dir="${ZCMDR[current_repo]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "The feature \`$feature' belongs to project: ${fg_bold[green]}\`${entries[2]:t:r}'${reset_color}. Proceed with update? [y/n]"
        local answer="n"
        read -qs answer
        if [[ "$answer" = "n" ]]; then
            echo "Aborting.."
            return 18
        else
            project_line="${entries[2]}"
            if ! -zcmdr_find_repo_path_in_recents "$project_line"; then
                print "Could not find repository of project \`${entries[2]:t:r}\' because"
                print "the project is not remembered in recent-projects database."
                print "Will perform without commit verification."
                root_dir=""
            else
                root_dir="$REPLY"
            fi
        fi
    fi

    local -a revision
    local cmt
    integer error=0
    if [[ -z "$root_dir" ]]; then
        # No-op, no commit verification
        :
    elif [[ -d "$root_dir"/.git ]]; then
        for cmt in "${commits[@]}"; do
            revision=( ${(f)"$( git -C "$root_dir" rev-parse --verify "${cmt}^{commit}" 2>/dev/null )"} )
            if [[ "${#revision}" = "0" ]]; then
                print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                error+=1
            fi
        done
    elif [[ -d "$root_dir"/.hg ]]; then
        for cmt in "${commits[@]}"; do
            revision=( ${(f)"$( hg --cwd "$root_dir" log -r "${cmt}" -T {node}\\n 2>/dev/null )"} )
            if [[ "${#revision}" = "0" ]]; then
                print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                error+=1
            fi
        done
    else
        print "Cannot set given commits – project isn't Git nor Hg repository"
        return 19
    fi

    if (( error > 0 )); then
        print "${fg_bold[red]}$error commit(s) not found, refusing to perform the update"
        return 20
    fi

    local files_line="${entries[3]}"
    local commits_line="commits ${commits[*]}"

    print -rl -- "# Feature \`$feature'" >! "$feature_file"
    print -rl -- "$project_line" >>! "$feature_file"
    print -rl -- "$files_line" >>! "$feature_file"
    print -rl -- "$commits_line" >>! "$feature_file"

    if (( quiet == 0 )); then
        if (( verbose == 1 )); then
            print -- "Feature ${fg_bold[green]}$feature${reset_color} (project: ${fg_bold[green]}${project_line:t:r}${reset_color}) updated, has the commits:"
            print -rl -- "${(Q)commits[@]}"
        else
            print -- "Feature ${fg_bold[green]}$feature${reset_color} (project: ${fg_bold[green]}${project_line:t:r}${reset_color}) updated"
        fi
    fi
    return 0
fi

if (( diff )); then
    if [[ "$#" -ne "1" ]]; then
        print "Exactly 1 argument is needed: a feature name, of which commits will be printed (diffs)"
        return 23
    fi

    local feature="$1"

    -zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local project_line="${ZCMDR[current_project]}"
    local root_dir="${ZCMDR[current_repo]}"

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "Warning: the feature \`$feature' belongs to not-current project: ${fg_bold[green]}\`${entries[2]:t:r}'${reset_color}"
        project_line="${entries[2]}"
        if ! -zcmdr_find_repo_path_in_recents "$project_line"; then
            print "Could not find repository of project \`${entries[2]:t:r}\' because"
            print "the project is not remembered in recent-projects database."
            print "Cannot continue, aborting"
            return 24
        else
            root_dir="$REPLY"
        fi
    fi

    local -a commits
    commits=( "${(z@)entries[4]}" )

    if [[ "${commits[1]}" != "commits" ]]; then
        print -- "Improper 4th line in the feature file \`$feature_file', should begin with \`commits' string"
        return 25
    elif [[ "${#commits}" -gt 1 ]]; then
        shift commits
    else
        print -- "Feature \`$feature' has no commits assigned"
        return 0
    fi

    integer error=0 is_git=0
    local cmt
    local -a vercommits

    if [[ -d "$root_dir"/.git ]]; then
        is_git=1
        for cmt in "${commits[@]}"; do
            revision=( ${(f)"$( git -C "$root_dir" rev-parse --verify "${cmt}^{commit}" 2>/dev/null )"} )
            if [[ "${#revision}" = "0" ]]; then
                print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                error+=1
            else
                vercommits+=( "${revision[1]}" )
            fi
        done
    elif [[ -d "$root_dir"/.hg ]]; then
        for cmt in "${commits[@]}"; do
            revision=( ${(f)"$( hg --cwd "$root_dir" log -r "${cmt}" -T {node}\\n 2>/dev/null )"} )
            if [[ "${#revision}" = "0" ]]; then
                print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                error+=1
            else
                vercommits+=( "${revision[1]}" )
            fi
        done
    else
        print "Cannot diff commits – project isn't Git nor Hg repository"
        return 26
    fi

    if (( error > 0 )); then
        if [[ "${#vercommits}" = "0" ]]; then
            print "${fg_bold[red]}Error: checked for the $error feature's commit(s) and didn't found, aborting"
            return 27
        else
            print "${fg_bold[red]}Warning: $error commit(s) not found"
        fi
    fi

    if (( is_git )); then
        if (( verbose == 0 )); then
            git -C "$root_dir" show --format=oneline --abbrev-commit --word-diff=color -p "${vercommits[@]}" -- | -zcmdr_stdlib_filter_diff | ${PAGER:-less}
        else
            git -C "$root_dir" show --format=oneline --no-abbrev-commit --word-diff=color -p "${vercommits[@]}" -- | -zcmdr_stdlib_filter_diff | ${PAGER:-less}
        fi
    fi
fi

if (( filesopt )); then
    if [[ "$#" -ne "1" ]]; then
        print "Exactly 1 argument is needed – a feature name commits of which will have files listed"
        return 21
    fi

    local feature="$1"
    shift

    -zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"
    local root_dir="${ZCMDR[current_repo]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "${fg_bold[red]}Warning: listing from a not current project \`${entries[2]:t:r}'${reset_color}"
        project_line="${entries[2]}"
        root_dir=""

        if ! -zcmdr_find_repo_path_in_recents "$project_line"; then
            print "Could not find repository of project \`${entries[2]:t:r}\' because"
            print "the project is not remembered in recent-projects database."
            print "Cannot read feature's commits (to list files), aborting.."
            return 28
        else
            root_dir="$REPLY"
        fi
    fi

    local -A commit_to_files_txt

    #
    # From-commit files of the feature
    #

    local -a commits
    commits=( "${(z@)entries[4]}" )
    if [[ -z "${commits[1]}" ]]; then
        commits=( )
    else
        shift commits
    fi

    commits=( "${(Q)commits[@]}" )

    if [[ -n "${commits[1]}" ]]; then
        if [[ -z "$root_dir" || ! -d "$root_dir" || ( ! -d "$root_dir"/.git && ! -d "$root_dir"/.hg ) ]]; then
            print "${fg_bold[red]}Error: feature has commits but project's dir isn't a Git nor Hg repository, aborting..${reset_color}"
            return 29
        else
            local cmt
            local -a files
            integer error=0
            if [[ -d "$root_dir"/.git ]]; then
                for cmt in "${commits[@]}"; do
                    files=( ${(f)"$( git -C "$root_dir" rev-parse --verify "${cmt}^{commit}" 2>/dev/null )"} )
                    if [[ "${#files[@]}" = "0" ]]; then
                        print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                        error+=1
                        continue
                    fi
                    # Get list of files (3 steps) of the commit
                    files=( ${(f)"$( git -C "$root_dir" show --name-status --no-renames "$cmt" )"} )
                    files=( "${(@M)files:#((#s)[ADM][ADM]#[[:space:]]##*|(#s)[ ][ADM][[:space:]]##*)}" )
                    files=( "${files[@]/(#b)(#s)[[:alpha:]]##[[:space:]]##(*)(#e)/${match[1]}}" )

                    commit_to_files_txt[$cmt]+="${(F)files[@]}"$'\n'
                done
            elif [[ -d "$root_dir"/.hg ]]; then
                for cmt in "${commits[@]}"; do
                    files=( ${(f)"$( hg --cwd "$root_dir" log -r "${cmt}" -T {node}\\n 2>/dev/null )"} )
                    if [[ "${#files[@]}" = "0" ]]; then
                        print "${fg_bold[red]}Commit $cmt (Hg) doesn't exist${reset_color}"
                        error+=1
                        continue
                    fi
                    # Get list of files of the commit
                    files=( ${(f)"$( hg --cwd "$root_dir" log -r "$cmt" -T {files}\\n )"} )

                    commit_to_files_txt[$cmt]+="${(F)files[@]}"$'\n'
                done
            fi


            if (( error > 0 )); then
                print "${fg_bold[red]}$error commit(s) not found${reset_color}"
            fi
        fi
    else
        print "The feature \`${fg_bold[magenta]}$feature${reset_color}' doesn't have assigned commits, no files to show"
        return 30
    fi

    (( quiet )) || print "Files in commits of feature \`${fg_bold[magenta]}$feature${reset_color}':"
    (( quiet )) || print
    for cmt in "${(k)commit_to_files_txt[@]}"; do
        print -- "Commit: ${fg_bold[green]}$cmt${reset_color}, files:"
        print -- "⇒  $commit_to_files_txt[$cmt]"
    done

    return 0
fi

if (( backup )); then
    if [[ "$#" != "1" ]]; then
        print "Exactly 1 arguments is needed – a feature to backup"
        return 21
    fi

    local feature="$1"
    shift

    -zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"
    local root_dir="${ZCMDR[current_repo]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "${fg_bold[red]}Warning: editing not current project \`${entries[2]:t:r}'${reset_color}"
        project_line="${entries[2]}"
        root_dir=""

        if (( extract )); then
            if ! -zcmdr_find_repo_path_in_recents "$project_line"; then
                print "Could not find repository of project \`${entries[2]:t:r}\' because"
                print "the project is not remembered in recent-projects database."
                print "Cannot use feature's commits, will only open feature's files."
                print "Proceed? [y/n]"
                local answer="n"
                read -qs answer
                if [[ "$answer" = "n" ]]; then
                    echo "Aborting."
                    return 22
                fi
            else
                root_dir="$REPLY"
            fi
        fi
    fi

    #
    # Direct files of the feature
    #

    local -aU files
    files=( "${(z@)entries[3]}" )
    # z-flag can do tricks IIRC
    if [[ -z "${files[1]}" ]]; then
        files=( )
    else
        shift files
    fi

    files=( "${(Q)files[@]}" )

    #
    # From-commit files of the feature
    #

    local -a commits
    commits=( "${(z@)entries[4]}" )
    if [[ -z "${commits[1]}" ]]; then
        commits=( )
    else
        shift commits
    fi

    commits=( "${(Q)commits[@]}" )

    if [[ -n "${commits[1]}" ]]; then
        if [[ "$extract" -eq "0" || -z "$root_dir" || ! -d "$root_dir" || ( ! -d "$root_dir"/.git && ! -d "$root_dir"/.hg ) ]]; then
            if [[ -n "$root_dir" && "$extract" != "0" ]]; then
                print "${fg_bold[red]}Warning: feature has commits but project's dir isn't a Git nor Hg repository${reset_color}"
            fi
        else
            local -aU save_files
            local cmt
            local -a files2
            integer error=0
            if [[ -d "$root_dir"/.git ]]; then
                for cmt in "${commits[@]}"; do
                    files2=( ${(f)"$( git -C "$root_dir" rev-parse --verify "${cmt}^{commit}" 2>/dev/null )"} )
                    if [[ "${#files2[@]}" = "0" ]]; then
                        print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                        error+=1
                        continue
                    fi
                    # Get list of files (3 steps) of the commit
                    files2=( ${(f)"$( git -C "$root_dir" show --name-status --no-renames "$cmt" )"} )
                    files2=( "${(@M)files2:#((#s)[ADM][ADM]#[[:space:]]##*|(#s)[ ][ADM][[:space:]]##*)}" )
                    files2=( "${files2[@]/(#b)(#s)[[:alpha:]]##[[:space:]]##(*)(#e)/${match[1]}}" )

                    save_files+=( "${files2[@]}" )
                done
            elif [[ -d "$root_dir"/.hg ]]; then
                for cmt in "${commits[@]}"; do
                    files2=( ${(f)"$( hg --cwd "$root_dir" log -r "${cmt}" -T {node}\\n 2>/dev/null )"} )
                    if [[ "${#files2[@]}" = "0" ]]; then
                        print "${fg_bold[red]}Commit $cmt (Hg) doesn't exist${reset_color}"
                        error+=1
                        continue
                    fi
                    # Get list of files of the commit
                    files2=( ${(f)"$( hg --cwd "$root_dir" log -r "$cmt" -T {files}\\n )"} )

                    save_files+=( "${files2[@]}" )
                done
            fi

            # Add from-commits gathered files
            files+=( "${save_files[@]}" )

            if (( error > 0 )); then
                print "${fg_bold[red]}$error commit(s) not found${reset_color}"
            fi
        fi
    fi

    #
    # Paths and editing
    #

    # Make absolute paths relative - if they're pointing to project dir
    files=( "${files[@]/(#s)$project_line\//}" )

    local dest
    zstyle -s ":plugin:zcommodore" backup_dir dest || dest="$HOME/.backup"

    [[ "${ZCMDR[cmdline_sourced]}" != "1" ]] && source "${ZCMDR_REPO_DIR}/lib/cmdline.lcmdr"
    cmdr_bdir -s

    -zcmdr_stdlib_get_date_and_time_string
    tar -C "$project_line" -czf "${dest}/feat_${feature}_${REPLY}.tgz" "${files[@]}"
    retcode=$?

    if (( retcode )); then
        if (( extract )); then
            print -- "Error code [$retcode] when creating archive of feature ${fg_bold[magenta]}$feature${reset_color} (with files of commits)"
        else
            print -- "Error code [$retcode] when creating archive of feature ${fg_bold[magenta]}$feature${reset_color} (without files of commits)"
        fi
        print -- "Target path: ${fg_bold[green]}${dest/(#s)$HOME/~}/feat_${feature}_${REPLY}.tgz${reset_color}"
    else
        if (( extract )); then
            print -- "${fg_bold[magenta]}$feature${reset_color} archived (also files from commits): ${fg_bold[green]}${dest/(#s)$HOME/~}/${feature}_${REPLY}.tgz${reset_color}"
        else
            print -- "${fg_bold[magenta]}$feature${reset_color} archived (no files from commits): ${fg_bold[green]}${dest/(#s)$HOME/~}/${feature}_${REPLY}.tgz${reset_color}"
        fi
    fi

    return $retcode
fi

if (( list + LIST + create + create_from_commits + add + delete + delete_feature + set_commits + diff + filesopt + backup == 0 )); then
    if [[ "$#" != "1" ]]; then
        print "Exactly 1 arguments is needed – a feature to edit"
        return 21
    fi

    local feature="$1"
    shift

    -zcmdr_verify_feature "$feature" "must_exist"
    retcode=$?
    (( retcode )) && return $retcode

    local feature_file="${features_path}/${feature}.conf"
    local -a entries
    entries=( "${(@f)"$(<$feature_file)"}" )

    local project_line="${ZCMDR[current_project]}"
    local root_dir="${ZCMDR[current_repo]}"

    if [[ "${entries[2]}" != "$project_line" ]]; then
        print "${fg_bold[red]}Warning: editing not current project \`${entries[2]:t:r}'${reset_color}"
        project_line="${entries[2]}"
        root_dir=""

        if (( extract )); then
            if ! -zcmdr_find_repo_path_in_recents "$project_line"; then
                print "Could not find repository of project \`${entries[2]:t:r}\' because"
                print "the project is not remembered in recent-projects database."
                print "Cannot use feature's commits, will only open feature's files."
                print "Proceed? [y/n]"
                local answer="n"
                read -qs answer
                if [[ "$answer" = "n" ]]; then
                    echo "Aborting."
                    return 22
                fi
            else
                root_dir="$REPLY"
            fi
        fi
    fi

    #
    # Direct files of the feature
    #

    local -aU files
    files=( "${(z@)entries[3]}" )
    # z-flag can do tricks IIRC
    if [[ -z "${files[1]}" ]]; then
        files=( )
    else
        shift files
    fi

    files=( "${(Q)files[@]}" )

    #
    # From-commit files of the feature
    #

    local -a commits
    commits=( "${(z@)entries[4]}" )
    if [[ -z "${commits[1]}" ]]; then
        commits=( )
    else
        shift commits
    fi

    commits=( "${(Q)commits[@]}" )

    if [[ -n "${commits[1]}" ]]; then
        if [[ "$extract" -eq "0" || -z "$root_dir" || ! -d "$root_dir" || ( ! -d "$root_dir"/.git && ! -d "$root_dir"/.hg ) ]]; then
            if [[ -n "$root_dir" && "$extract" != "0" ]]; then
                print "${fg_bold[red]}Warning: feature has commits but project's dir isn't a Git nor Hg repository${reset_color}"
            fi
        else
            local -aU save_files
            local cmt
            local -a files2
            integer error=0
            if [[ -d "$root_dir"/.git ]]; then
                for cmt in "${commits[@]}"; do
                    files2=( ${(f)"$( git -C "$root_dir" rev-parse --verify "${cmt}^{commit}" 2>/dev/null )"} )
                    if [[ "${#files2[@]}" = "0" ]]; then
                        print "${fg_bold[red]}Commit $cmt doesn't exist${reset_color}"
                        error+=1
                        continue
                    fi
                    # Get list of files (3 steps) of the commit
                    files2=( ${(f)"$( git -C "$root_dir" show --name-status --no-renames "$cmt" )"} )
                    files2=( "${(@M)files2:#((#s)[ADM][ADM]#[[:space:]]##*|(#s)[ ][ADM][[:space:]]##*)}" )
                    files2=( "${files2[@]/(#b)(#s)[[:alpha:]]##[[:space:]]##(*)(#e)/${match[1]}}" )

                    save_files+=( "${files2[@]}" )
                done
            elif [[ -d "$root_dir"/.hg ]]; then
                for cmt in "${commits[@]}"; do
                    files2=( ${(f)"$( hg --cwd "$root_dir" log -r "${cmt}" -T {node}\\n 2>/dev/null )"} )
                    if [[ "${#files2[@]}" = "0" ]]; then
                        print "${fg_bold[red]}Commit $cmt (Hg) doesn't exist${reset_color}"
                        error+=1
                        continue
                    fi
                    # Get list of files of the commit
                    files2=( ${(f)"$( hg --cwd "$root_dir" log -r "$cmt" -T {files}\\n )"} )

                    save_files+=( "${files2[@]}" )
                done
            fi

            # Add from-commits gathered files
            files+=( "${save_files[@]}" )

            if (( error > 0 )); then
                print "${fg_bold[red]}$error commit(s) not found${reset_color}"
            fi
        fi
    fi

    #
    # Echo
    #

    local feature_edit_echo
    zstyle -T ":plugin:zcommodore" feature_edit_echo && feature_edit_echo="yes" || feature_edit_echo="no"
    if [[ "$feature_edit_echo" = "yes" ]]; then
        print -- "Editing: ${files[*]}"
    fi

    #
    # Paths and editing
    #

    # If at correct location or if going to CD
    if [[ "$project_line" = "$PWD" || "$cd_at_edit" = "yes" ]]; then
        files=( "${files[@]/(#s)$project_line\//}" )
    else
        files=( "${files[@]/(#b)(#s)([^\/]*)/${project_line}/${match[1]}}" )
    fi

    [[ "$cd_at_edit" = "yes" && "$project_line" != "$PWD" ]] && cd "$project_line"

    local -a opts
    case "$selected_editor" in
        (vim|gvim|mvim|nvim)
            [[ "$editor_use_tabs" = "yes" ]] && opts+=( "-p" )
            ;;
        (emacs|emacsclient)
            ;;
        (gedit)
            ;;
        (nano)
            ;;
        (editor)
            # TODO
            ;;
    esac
    "$selected_editor" "${opts[@]}" -- "${files[@]}"
fi

return 0

# vim:ft=zsh
